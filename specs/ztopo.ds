TileCache:

    type State = enum {
        Disk, Loading, DiskAndMemory, MemoryOnly,
        Saving, NetworkPending, IndexPending, Invalid }
    type Key = Long
    type Entry = {
        key : Key,
        pixmap : Int,    // todo
        indexData : Int, // todo
        memSize : Int,
        diskSize : Int,
        st : State,
        inUse : Bool }

    state entries : Bag<Entry>

    assume unique [e.val.key | e <- entries];

    op add(e : entries.Handle)
        entries.add(e)

    op rm(e : entries.Handle)
        entries.remove(e)

//    op updateState(e : entries.Handle, st : State)
//        e.val.st = st

    query totalMemSize()
        sum [e.val.memSize | e <- entries, e.val.st == DiskAndMemory or e.val.st == MemoryOnly]

    query totalDiskSize()
        sum [e.val.diskSize | e <- entries, e.val.st == Disk]

    query diskEntries()
        [e | e <- entries, e.val.st == Disk]

    query pendingEntries()
        [e | e <- entries, e.val.st == IndexPending]

    query inMemEntries(inUse : Bool)
        [e | e <- entries, (e.val.st == DiskAndMemory or e.val.st == MemoryOnly), e.val.inUse == inUse]

//    query findTile(k : Key)
//        some [e | e <- entries, e.val.key == k]
