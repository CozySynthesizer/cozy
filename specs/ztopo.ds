TileCache:

    type State = enum {
        Disk, Loading, DiskAndMemory, MemoryOnly,
        Saving, NetworkPending, IndexPending, Invalid }
    type Key = Long
    type Entry = Handle<{
        key : Key,
        pixmap : Int,    // todo
        indexData : Int, // todo
        memSize : Int,
        diskSize : Int,
        st : State,
        inUse : Bool }>

    state entries : List<Entry>

    assume unique [e.val.key | e <- entries];

    op add(k : Key)
        entries.addBack(new Entry(k, 0, 0, 0, 0, IndexPending, true))

    op rm(e : Entry)
        assume e in entries;
        del e

    op updateState(e : Entry, st : State)
        assume e in entries;
        e.val.st = st

    query totalMemSize()
        sum [e.val.memSize | e <- entries, e.val.st == DiskAndMemory or e.val.st == MemoryOnly]

    query totalDiskSize()
        sum [e.val.diskSize | e <- entries, e.val.st == Disk]

    query diskEntries()
        [e | e <- entries, e.val.st == Disk]

    query pendingEntries()
        [e | e <- bag(entries), e.val.st == IndexPending]

    query inMemEntries(inUse : Bool)
        [e | e <- entries, (e.val.st == DiskAndMemory or e.val.st == MemoryOnly), e.val.inUse == inUse]

    query findTile(k : Key)
        some [e | e <- entries, e.val.key == k]
